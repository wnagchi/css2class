// 精简日志版 class2css 主流程脚本（增量更新 + 静态类生成修复版 + 文件变化时全量缓存更新）
const fs = require('fs').promises;
const path = require('path');
const chokidar = require('chokidar');
let config = require('./class2css.config.js');

// globby 兼容 require (新版用 .default，推荐v11及以下)
let globby;
try {
  globby = require('globby');
  if (typeof globby !== 'function' && globby.default) globby = globby.default;
} catch (e) {
  console.error('缺少 globby 依赖，请先执行 npm install globby@11');
  process.exit(1);
}

let baseUnit = config.baseUnit || 'px';
let multiFile = config.multiFile;

// ====== 自定义 !important 标识配置 ======
let importantFlags = {
  prefix: config.importantFlags?.prefix || ['!'],           // 前缀标识，如: !w-100
  suffix: config.importantFlags?.suffix || ['_i', '-i'],   // 后缀标识，如: w-100_i, w-100-i
  custom: config.importantFlags?.custom || []              // 自定义标识，如: ['__imp', '--important']
};

const isObject = obj => Object.prototype.toString.call(obj) === '[object Object]';
const isArray = obj => Object.prototype.toString.call(obj) === '[object Array]';

let classListSet = new Set();
let userBaseClassListSet = new Set();
let userStaticClassListSet = new Set();
let cssWrite = new Set();
let isScanning = false; // 标记是否处于全量扫描阶段
let scanCompletedTime = null; // 记录全量扫描完成时间
let initialScanComplete = false; // 标记初始扫描是否完全就绪

// ====== 全量扫描只读数据存储 ======
let fullScanReadOnlyData = {
  classListSet: new Set(),
  userStaticClassListSet: new Set(),
  userBaseClassListSet: new Set(),
  scanTime: null,
  isLocked: false // 锁定标识，确保只读
};

// ====== 修改：全局样式缓存管理系统 ======
let globalStyleCache = {
  classListSet: new Set(),
  userStaticClassListSet: new Set(),
  userBaseClassListSet: new Set(),
  fileClassMap: new Map(), // 记录每个文件包含的class
  lastUpdateTime: Date.now()
};

let userBaseClass = Object.entries(config.baseClassName).filter(([k, v]) => typeof v === 'object');
let userStaticClass = Object.entries(config.baseClassName).filter(([k, v]) => typeof v === 'string');

// 启动时打印配置信息
console.log('====== 配置信息 ======');
console.log('userBaseClass:', userBaseClass.length, '个');
console.log('userStaticClass:', userStaticClass.length, '个');
console.log('userStaticClass内容:', userStaticClass);

// ====== 性能优化：预编译正则表达式（支持自定义标识）======
function compileImportantRegex() {
  const allFlags = [
    ...importantFlags.prefix.map(flag => `^${escapeRegex(flag)}`),
    ...importantFlags.suffix.map(flag => `${escapeRegex(flag)}$`),
    ...importantFlags.custom.map(flag => escapeRegex(flag))
  ];
  
  return {
    classAttr: /class=(\"[^\"]*\"|'[^']*')/g,
    classNames: /[\w\-!]+/g,
    importantFlag: new RegExp(allFlags.join('|')),
    twoPartClass: /^([a-zA-Z_]+)-(.+)$/,
    percentageValue: /(\d+)b$/
  };
}

function escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

let COMPILED_REGEX = compileImportantRegex();

// ====== 性能优化：索引和缓存（动态更新） ======
let cssNameMap = new Map(Object.entries(config.cssName));
let baseClassNameMap = new Map(Object.entries(config.baseClassName));
let userStaticClassSet = new Set(userStaticClass.map(([k]) => k));

// ====== 配置更新函数 ======
function updateConfigReferences() {
  baseUnit = config.baseUnit || 'px';
  multiFile = config.multiFile;
  
  // 更新自定义 important 标识
  importantFlags = {
    prefix: config.importantFlags?.prefix || ['!'],
    suffix: config.importantFlags?.suffix || ['_i', '-i'],
    custom: config.importantFlags?.custom || []
  };
  
  // 重新编译正则表达式
  COMPILED_REGEX = compileImportantRegex();
  
  userBaseClass = Object.entries(config.baseClassName).filter(([k, v]) => typeof v === 'object');
  userStaticClass = Object.entries(config.baseClassName).filter(([k, v]) => typeof v === 'string');
  
  // 重建索引和缓存
  cssNameMap = new Map(Object.entries(config.cssName));
  baseClassNameMap = new Map(Object.entries(config.baseClassName));
  userStaticClassSet = new Set(userStaticClass.map(([k]) => k));
  
  logInfo('配置引用已更新，索引已重建，自定义 important 标识已生效');
}

// ====== 简化的缓存和内存管理 ======
class FileCache {
  constructor(maxSize = 1000) {
    this.cache = new Map();
    this.maxSize = maxSize;
    this.stats = new Map();
  }
  
  async getFileContent(filePath) {
    try {
      const stat = await fs.stat(filePath);
      const cached = this.cache.get(filePath);
      const cachedStat = this.stats.get(filePath);
      
      if (cached && cachedStat && stat.mtime.getTime() === cachedStat) {
        return cached;
      }
      
      const content = await fs.readFile(filePath, 'utf-8');
      
      if (this.cache.size >= this.maxSize) {
        const oldestKey = this.cache.keys().next().value;
        this.cache.delete(oldestKey);
        this.stats.delete(oldestKey);
      }
      
      this.cache.set(filePath, content);
      this.stats.set(filePath, stat.mtime.getTime());
      return content;
    } catch (e) {
      logError(`读取文件失败: ${filePath} - ${e.message}`);
      return null;
    }
  }
  
  clear() {
    this.cache.clear();
    this.stats.clear();
  }
}

const fileCache = new FileCache();

// ====== 修改：增强的SmartThrottle，支持任务排序 ======
class SmartThrottle {
  constructor() {
    this.timers = new Map();
    this.pending = new Set();
    this.priorities = new Map(); // 新增优先级支持
  }
  
  throttle(key, fn, delay = 200, priority = 0) {
    // 如果有更高优先级的任务，取消当前任务
    if (this.pending.has(key)) {
      const currentPriority = this.priorities.get(key) || 0;
      if (priority <= currentPriority) {
        return; // 当前任务优先级不够高，忽略
      } else {
        // 取消当前较低优先级的任务
        this.cancel(key);
      }
    }
    
    this.pending.add(key);
    this.priorities.set(key, priority);
    
    if (this.timers.has(key)) {
      clearTimeout(this.timers.get(key));
    }
    
    const timer = setTimeout(() => {
      this.pending.delete(key);
      this.timers.delete(key);
      this.priorities.delete(key);
      fn();
    }, delay);
    
    this.timers.set(key, timer);
  }
  
  cancel(key) {
    if (this.timers.has(key)) {
      clearTimeout(this.timers.get(key));
      this.timers.delete(key);
      this.pending.delete(key);
      this.priorities.delete(key);
    }
  }
}

const smartThrottle = new SmartThrottle();

function logInfo(msg) {
  const timeStr = `[${new Date().toLocaleString()}]`;
  console.log(timeStr, msg);
}
function logError(msg) {
  const timeStr = `[${new Date().toLocaleString()}]`;
  console.error(timeStr, msg);
}

// 显示当前配置的 important 标识
logInfo(`启动 class2css 构建脚本（性能优化版 + 配置热重载 + 自定义!important标识 + 增量更新 + 文件变化全量缓存更新）`);
logInfo(`当前 important 标识配置: 前缀[${importantFlags.prefix.join(', ')}] 后缀[${importantFlags.suffix.join(', ')}] 自定义[${importantFlags.custom.join(', ')}]`);

// ====== 新增：全量缓存更新函数 ======
async function updateFullScanCache() {
  logInfo('[全量缓存更新] 开始更新全量扫描缓存数据...');
  
  // 临时存储新的全量数据
  const tempFullScanData = {
    classListSet: new Set(),
    userStaticClassListSet: new Set(),
    userBaseClassListSet: new Set(),
    scanTime: Date.now(),
    isLocked: false
  };
  
  const types = multiFile?.entry?.fileType || ['html', 'wxml'];
  const scanPattern = types.map(type => `${multiFile.entry.path.replace(/\\/g, '/')}/**/*.${type}`);
  
  try {
    const fileList = await globby(scanPattern);
    logInfo(`[全量缓存更新] 重新扫描 ${fileList.length} 个文件...`);
    
    // 重新扫描所有文件
    for (const filePath of fileList) {
      try {
        const html = await fileCache.getFileContent(filePath);
        if (html) {
          const classInfo = parseClassOptimized(html);
          
          // 存储到临时全量数据中
          classInfo.classArr.forEach(cls => {
            tempFullScanData.classListSet.add(cls);
          });
          classInfo.userStaticClassArr.forEach(cls => {
            tempFullScanData.userStaticClassListSet.add(cls);
          });
        }
      } catch (e) {
        logError(`[全量缓存更新] 解析异常: ${filePath} - ${e.message}`);
      }
    }
    
    // 锁定新的全量数据并替换原有数据
    tempFullScanData.isLocked = true;
    tempFullScanData.scanTime = Date.now();
    
    // 原子性替换全量扫描只读数据
    fullScanReadOnlyData = tempFullScanData;
    
    logInfo(`[全量缓存更新] 完成 - 新的全量数据: class(${fullScanReadOnlyData.classListSet.size}), static(${fullScanReadOnlyData.userStaticClassListSet.size})`);
    
  } catch (e) {
    logError(`[全量缓存更新] 更新异常: ${e.message}`);
  }
}

// ====== 修改：配置变更时也更新全量缓存 ======
const configWatcher = chokidar.watch('./class2css.config.js');
configWatcher.on('change', async () => {
  try {
    logInfo('检测到配置文件变化，开始重载...');
    
    delete require.cache[require.resolve('./class2css.config.js')];
    const newConfig = require('./class2css.config.js');
    
    Object.assign(config, newConfig);
    updateConfigReferences();
    
    classListSet.clear();
    userStaticClassListSet.clear();
    cssWrite.clear();
    fileCache.clear();
    
    // 重置全量扫描只读数据
    fullScanReadOnlyData = {
      classListSet: new Set(),
      userStaticClassListSet: new Set(),
      userBaseClassListSet: new Set(),
      scanTime: null,
      isLocked: false
    };
    
    globalStyleCache = {
      classListSet: new Set(),
      userStaticClassListSet: new Set(),
      userBaseClassListSet: new Set(),
      fileClassMap: new Map(),
      lastUpdateTime: Date.now()
    };
    
    logInfo('配置文件已重载');
    
    // 配置变更后进行全量扫描和缓存更新
    await scanAllFilesAndBuild();
    
  } catch (error) {
    logError(`配置文件重载失败: ${error.message}`);
  }
});

// ====== 修改：全量扫描并存储只读数据 ======
async function scanAllFilesAndBuild() {
  if (isScanning) {
    logInfo('[scanAllFiles] 正在扫描中，跳过重复调用');
    return;
  }
  
  isScanning = true;
  initialScanComplete = false;
  scanCompletedTime = null;
  
  // 重置全量扫描只读数据（只在扫描开始时可写）
  fullScanReadOnlyData = {
    classListSet: new Set(),
    userStaticClassListSet: new Set(),
    userBaseClassListSet: new Set(),
    scanTime: Date.now(),
    isLocked: false
  };
  
  // 清空当前使用的样式集合
  classListSet = new Set();
  userStaticClassListSet = new Set();
  cssWrite = new Set();
  
  const types = multiFile?.entry?.fileType || ['html', 'wxml'];
  const scanPattern = types.map(type => `${multiFile.entry.path.replace(/\\/g, '/')}/**/*.${type}`);
  logInfo(`[scanAllFiles] 扫描文件模式: ${JSON.stringify(scanPattern)}`);

  try {
    const fileList = await globby(scanPattern);
    logInfo(`[scanAllFiles] 找到 ${fileList.length} 个文件，开始逐个扫描...`);
    
    // 逐个文件扫描并存储到只读数据中
    for (const filePath of fileList) {
      try {
        const html = await fileCache.getFileContent(filePath);
        if (html) {
          const classInfo = parseClassOptimized(html);
          
          // 存储到全量扫描只读数据
          classInfo.classArr.forEach(cls => {
            fullScanReadOnlyData.classListSet.add(cls);
          });
          classInfo.userStaticClassArr.forEach(cls => {
            fullScanReadOnlyData.userStaticClassListSet.add(cls);
          });
        }
      } catch (e) {
        logError(`[全量扫描] 解析异常: ${filePath} - ${e.message}`);
      }
    }
    
    // 锁定全量扫描数据，确保只读
    fullScanReadOnlyData.isLocked = true;
    fullScanReadOnlyData.scanTime = Date.now();
    
    // 将全量扫描数据复制到当前使用的集合中
    fullScanReadOnlyData.classListSet.forEach(cls => classListSet.add(cls));
    fullScanReadOnlyData.userStaticClassListSet.forEach(cls => userStaticClassListSet.add(cls));
    
    logInfo(`[scanAllFiles] 全量扫描完成并锁定只读数据 - class: ${fullScanReadOnlyData.classListSet.size}, static: ${fullScanReadOnlyData.userStaticClassListSet.size}`);
    logInfo(`[scanAllFiles] 当前工作集合 - class: ${classListSet.size}, static: ${userStaticClassListSet.size}`);
    
    // 生成完整CSS
    let { cssStr, userBaseClassArr } = getClassList(classListSet);
    let StaticClassStr = creatStaticClass(userStaticClassListSet);
    let userBaseClassStr = creatUserBaseClassList(userBaseClassArr);
    const rendStr = cssStr + StaticClassStr + userBaseClassStr;
    
    const firstFileInfo = fileList.length > 0 ? {
      fileName: path.basename(fileList[0]),
      fileType: path.extname(fileList[0]).substring(1),
      filePath: path.dirname(fileList[0]),
      fileTName: path.basename(fileList[0], path.extname(fileList[0])),
      path: fileList[0],
    } : {};
    
    await writeCssStr(rendStr, true, firstFileInfo);
    logInfo('[scanAllFiles] 全量构建已完成。');
    
    scanCompletedTime = Date.now();
    setTimeout(() => {
      isScanning = false;
      initialScanComplete = true;
      logInfo('[scanAllFiles] 文件监听已启用');
    }, 1500);
    
  } catch(e) {
    logError(`[scanAllFiles] 扫描异常: ${e.message}`);
    isScanning = false;
  }
}

// 初始启动
scanAllFilesAndBuild()
  .then(() => logInfo('[scanAllFiles] 初始化流程已启动。'))
  .catch(e => logError(`[scanAllFiles] 扫描异常: ${e.message}`));

// ====== 修改：文件监听配置和事件处理 ======
let watcher;

function createFileWatcher() {
  if (watcher) {
    watcher.close();
  }
  
  const types = multiFile?.entry?.fileType || ['html', 'wxml'];
  const watchList = types.map(type => `${multiFile.entry.path.replace(/\\/g, '/')}/**/*.${type}`);
  logInfo(`[监听路径] ${JSON.stringify(watchList)}`);

  watcher = chokidar.watch(watchList, {
    ignoreInitial: false,
    persistent: true,
    usePolling: true,
    interval: 150,
    binaryInterval: 300
  });
  
  watcher.on('all', (event, filePath) => {
    onFileEventOptimized(filePath, event === 'add');
  });
}

createFileWatcher();

configWatcher.on('change', () => {
  setTimeout(() => {
    createFileWatcher();
    logInfo('文件监听器已根据新配置重建');
  }, 100);
});

// ====== 修改：事件入口（增加全量缓存更新） ======
function onFileEventOptimized(filePath, firstBuild) {
  if (isScanning) {
    logInfo(`[监听跳过] 正在全量扫描，忽略监听事件: ${filePath}`);
    return;
  }
  
  if (!initialScanComplete) {
    logInfo(`[监听跳过] 初始扫描未完全就绪，忽略事件: ${filePath}`);
    return;
  }
  
  const now = Date.now();
  if (scanCompletedTime && (now - scanCompletedTime) < 3000) {
    logInfo(`[监听跳过] 全量扫描刚完成，忽略可能的延迟事件: ${filePath}`);
    return;
  }
  
  // 先触发全量缓存更新（高优先级）
  smartThrottle.throttle('fullScanUpdate', () => {
    updateFullScanCache();
  }, 500, 10); // 稍长的延迟确保文件写入完成，高优先级
  
  // 然后处理单个文件变更（普通优先级）
  smartThrottle.throttle(filePath, () => {
    const fileInfo = {
      fileName: path.basename(filePath),
      fileType: path.extname(filePath).substring(1),
      filePath: path.dirname(filePath),
      fileTName: path.basename(filePath, path.extname(filePath)),
      path: filePath,
    };
    fileChange(fileInfo, firstBuild);
  }, 800, 1); // 延迟执行，确保全量缓存更新先完成，普通优先级
}

function fileChange(fileInfo, firstBuild) {
  let run = false;
  if (multiFile?.entry?.fileName?.length) {
    if (multiFile.entry.fileName.includes(fileInfo.fileName)) {
      run = true;
    } else if (multiFile?.entry?.fileType?.length) {
      if (multiFile.entry.fileType.includes(fileInfo.fileType)) run = true;
    }
  } else {
    if (multiFile?.entry?.fileType?.length) {
      if (multiFile.entry.fileType.includes(fileInfo.fileType)) run = true;
    } else {
      run = true;
    }
  }
  if (run) {
    logInfo(`开始构建: ${fileInfo.path}`);
    writeCss(fileInfo, firstBuild);
  }
}

// ====== 自定义 !important 功能支持 ======

function hasImportantFlag(className) {
  for (const prefix of importantFlags.prefix) {
    if (className.startsWith(prefix)) {
      return true;
    }
  }
  
  for (const suffix of importantFlags.suffix) {
    if (className.endsWith(suffix)) {
      return true;
    }
  }
  
  for (const custom of importantFlags.custom) {
    if (className.includes(custom)) {
      return true;
    }
  }
  
  return false;
}

function cleanImportantFlag(className) {
  let cleanName = className;
  
  for (const prefix of importantFlags.prefix) {
    if (cleanName.startsWith(prefix)) {
      cleanName = cleanName.substring(prefix.length);
      break;
    }
  }
  
  for (const suffix of importantFlags.suffix) {
    if (cleanName.endsWith(suffix)) {
      cleanName = cleanName.substring(0, cleanName.length - suffix.length);
      break;
    }
  }
  
  for (const custom of importantFlags.custom) {
    if (cleanName.includes(custom)) {
      cleanName = cleanName.replace(custom, '');
      break;
    }
  }
  
  return cleanName;
}

function addImportantToCss(cssValue, isImportant) {
  if (!isImportant) return cssValue;
  
  if (cssValue.includes('!important')) return cssValue;
  
  const cleanValue = cssValue.replace(/;?\s*$/, '');
  return `${cleanValue} !important;`;
}

// class 解析器 - 优化版，支持自定义 !important 标识
function parseClassOptimized(htmlStr) {
  const classList = new Set();
  const userStaticList = new Set();
  
  let match;
  while ((match = COMPILED_REGEX.classAttr.exec(htmlStr)) !== null) {
    const classStr = match[1].slice(1, -1); // 移除引号
    
    const classes = classStr.split(/\s+/).filter(Boolean);
    
    for (const className of classes) {
      const cleanName = cleanImportantFlag(className);
      
      // 先检查是否是静态类
      if (userStaticClassSet.has(cleanName)) {
        userStaticList.add(className);
        logInfo(`[Static Class Found] ${className} -> ${cleanName}`);
      }
      
      // 再检查是否是动态类
      if (cleanName.includes('-')) {
        classList.add(className);
      }
    }
  }
  
  return {
    userStaticClassArr: Array.from(userStaticList),
    classArr: Array.from(classList)
  };
}

// 向后兼容的 parseClass 函数
function parseClass(htmlStr) {
  const result = parseClassOptimized(htmlStr);
  
  logInfo(`[LOG3][parseClass] classArr: ${JSON.stringify([...new Set(result.classArr)].sort())}`);
  logInfo(`[LOG4][parseClass] userStaticClassArr: ${JSON.stringify([...new Set(result.userStaticClassArr)].sort())}`);
  
  return {
    userStaticClassArr: [...new Set(result.userStaticClassArr)].sort(),
    classArr: [...new Set(result.classArr)].sort(),
  };
}

// CSS 生成器
function getClassList(classArr) {
  logInfo(`[LOG5][getClassList] classArr: ${JSON.stringify(Array.from(classArr))}`);
  const unitConversion = Number(config.unitConversion) || 1;
  let cssStr = '';
  let userBaseClassArr = [];
  
  classArr.forEach((x) => {
    const isImportant = hasImportantFlag(x);
    const cleanClassName = cleanImportantFlag(x);
    let name = cleanClassName.split('-');
    
    if (name.length !== 2) return;
    
    if (cssNameMap.has(name[0])) {
      cssStr += getClassListStr([name[0], name[1]], x, isImportant);
    } else {
      userBaseClassArr.push([name[0], name[1], x, isImportant]);
    }
  });
  
  return { cssStr, userBaseClassArr };
}

function getClassListStr(name, originalClassName, isImportant = false) {
  const classNameDefinition = cssNameMap.get(name[0]);
  const unitConversion = Number(config.unitConversion) || 1;
  let unit = baseUnit, size = name[1];
  let sizeArr = size.split('');
  
  if (isObject(classNameDefinition)) {
    if (!classNameDefinition.classArr) return '';
    
    if (classNameDefinition.unit === '-') {
      unit = '';
    } else if (sizeArr[sizeArr.length - 1] === 'b') {
      size = sizeArr.slice(0, sizeArr.length - 1).join('') + '%';
      unit = '';
    } else if (classNameDefinition.unit !== undefined) {
      unit = classNameDefinition.unit;
      size = unitConversion * size;
    } else {
      // 修复：统一应用单位转换
      size = unitConversion * size;
    }
    
    // 关键修复：确保 size 是字符串类型
    if (name[1][0] === '0') {
      size = String(size).replace('0', '0.');
    }
    
    let str = `\n.${originalClassName} {\n`;
    classNameDefinition.classArr.forEach((y) => {
      const cssValue = `${size}${unit}`;
      const finalValue = isImportant ? `${cssValue} !important` : cssValue;
      str += `  ${y}: ${finalValue};\n`;
    });
    str += `}\n`;
    return str;
  } else {
    if (sizeArr[sizeArr.length - 1] === 'b') {
      size = sizeArr.slice(0, sizeArr.length - 1).join('') + '%';
      unit = '';
    } else {
      size = unitConversion * size;
    }
    
    // 关键修复：确保 size 是字符串类型
    if (name[1][0] === '0') {
      size = String(size).replace('0', '0.');
    }
    
    const cssValue = `${size}${unit}`;
    const finalValue = isImportant ? `${cssValue} !important` : cssValue;
    return `\n.${originalClassName} {\n  ${classNameDefinition}: ${finalValue};\n}\n`;
  }
}


function creatUserBaseClassList(arr) {
  let str = '';
  
  arr.forEach((x) => {
    let item = userBaseClass.find((y) => y[0] === x[0]);
    const originalClassName = x[2];
    const isImportant = x[3];
    const classKey = originalClassName;
    
    if (item !== undefined && !cssWrite.has(classKey)) {
      cssWrite.add(classKey);
      let className = x[0].replaceAll('_', '-');
      
      if (isArray(item[1])) {
        const cssValue = isImportant ? `${x[1]} !important` : x[1];
        str += `\n.${originalClassName} {\n  ${className}: ${cssValue}\n}\n`;
      } else if (isObject(item[1]) && item[1][x[1]] !== undefined) {
        const cssValue = isImportant ? `${item[1][x[1]]} !important` : item[1][x[1]];
        str += `\n.${originalClassName} {\n  ${(item[1]['ABBR'] || className)}: ${cssValue}\n}\n`;
      }
    }
  });
  
  return str;
}

// **关键修复：静态类生成函数，增加详细调试信息**
function creatStaticClass(list) {
  let str = '';
  
  logInfo(`[DEBUG] creatStaticClass 开始处理: ${JSON.stringify(Array.from(list))}`);
  logInfo(`[DEBUG] userStaticClass 配置: ${JSON.stringify(userStaticClass.map(([k, v]) => [k, v]))}`);
  logInfo(`[DEBUG] cssWrite 当前状态: ${JSON.stringify(Array.from(cssWrite))}`);
  
  list.forEach((x) => {
    const isImportant = hasImportantFlag(x);
    const cleanClassName = cleanImportantFlag(x);
    let staticItem = userStaticClass.find((y) => y[0] === cleanClassName);
    
    logInfo(`[DEBUG] 处理静态类: ${x} -> 清理后: ${cleanClassName} -> 找到配置: ${staticItem ? `[${staticItem[0]}, ${staticItem[1]}]` : 'null'}`);
    
    const uniqueKey = x;
    
    if (staticItem && !cssWrite.has(uniqueKey)) {
      cssWrite.add(uniqueKey);
      let cssContent = staticItem[1];
      
      if (isImportant) {
        cssContent = addImportantToCss(cssContent, true);
      }
      
      str += `\n.${x} {\n  ${cssContent}\n}\n`;
      logInfo(`[Static CSS Generated] ${x} -> ${cssContent}`);
    } else {
      if (!staticItem) {
        logInfo(`[DEBUG] 静态类 ${x} 未找到配置`);
      } else if (cssWrite.has(uniqueKey)) {
        logInfo(`[DEBUG] 静态类 ${x} 已存在于 cssWrite 中，跳过重复生成`);
      }
    }
  });
  
  logInfo(`[DEBUG] creatStaticClass 生成的CSS长度: ${str.length}`);
  return str;
}

// ====== 修改：统一文件模式处理（使用更新后的全量缓存） ======
async function handleUnifiedFileMode(fileInfo, classInfo, firstBuild) {
  const filePath = fileInfo.path;
  
  logInfo(`[增量更新] 文件 ${path.basename(filePath)} - 当前文件样式: class(${classInfo.classArr.length}) static(${classInfo.userStaticClassArr.length})`);
  
  // 等待全量缓存更新完成
  let retryCount = 0;
  const maxRetries = 5;
  
  while (!fullScanReadOnlyData.isLocked && retryCount < maxRetries) {
    logInfo('[增量更新] 等待全量缓存更新完成...');
    await new Promise(resolve => setTimeout(resolve, 200));
    retryCount++;
  }
  
  if (!fullScanReadOnlyData.isLocked) {
    logError('[增量更新] 全量扫描只读数据未锁定，使用当前文件数据');
    // 降级处理：直接使用当前文件数据
    classListSet.clear();
    userStaticClassListSet.clear();
    classInfo.classArr.forEach(cls => classListSet.add(cls));
    classInfo.userStaticClassArr.forEach(cls => userStaticClassListSet.add(cls));
  } else {
    // 合并当前文件的class与更新后的全量扫描只读数据
    const mergedClassSet = new Set(fullScanReadOnlyData.classListSet);
    const mergedStaticClassSet = new Set(fullScanReadOnlyData.userStaticClassListSet);
    
    // 当前文件的新样式已经包含在更新后的全量数据中，无需额外添加
    
    // 更新当前工作集合为合并后的完整数据
    classListSet.clear();
    userStaticClassListSet.clear();
    
    mergedClassSet.forEach(cls => classListSet.add(cls));
    mergedStaticClassSet.forEach(cls => userStaticClassListSet.add(cls));
    
    logInfo(`[增量更新] 使用更新后的全量数据 - 总 class: ${mergedClassSet.size}, 总 static: ${mergedStaticClassSet.size}`);
  }
  
  // 基于合并后的完整数据重新生成CSS
  clearTimeout(writeCss.writeCssStrSetTime);
  writeCss.writeCssStrSetTime = setTimeout(async () => {
    // 确保每次重新生成时清空cssWrite
    cssWrite.clear();
    logInfo(`[增量更新] 清空 cssWrite，准备重新生成CSS`);
    
    let { cssStr, userBaseClassArr } = getClassList(classListSet);
    let StaticClassStr = creatStaticClass(userStaticClassListSet);
    let userBaseClassStr = creatUserBaseClassList(userBaseClassArr);
    const rendStr = cssStr + StaticClassStr + userBaseClassStr;
    await writeCssStr(rendStr, firstBuild, fileInfo);
    
    logInfo(`[增量更新完成] 基于更新后的全量数据重新生成CSS - class: ${classListSet.size}, static: ${userStaticClassListSet.size}`);
  }, 300);
}

// 写入 CSS
async function writeCssStr(str, firstBuild, fileInfo) {
  let cssPath = config.output?.path;
  let cssFileName = config.output?.fileName;
  if (multiFile) {
    if (multiFile.output?.cssOutType === 'filePath') {
      cssPath = multiFile.output?.path || fileInfo.filePath;
      cssFileName = fileInfo.fileTName + '.' + config.multiFile.output.fileType;
    } else {
      cssPath = multiFile.output.path;
      cssFileName = config.multiFile.output.fileName;
    }
  }
  let writePath = path.join(cssPath, cssFileName);
  try {
    let cssStr = config.compression ? str.replace(/\s+/g, '') : str;
    
    await fs.mkdir(cssPath, { recursive: true });
    await fs.writeFile(writePath, cssStr);
    logInfo(`CSS 写入成功: ${writePath}`);
  } catch (err) {
    logError('写入CSS失败：' + err.message);
  }
}

// 添加一个静态属性来存储定时器
writeCss.writeCssStrSetTime = null;

// ====== 修改：直接文件模式处理（使用更新后的全量缓存） ======
async function writeCss(fileInfo, firstBuild = false) {
  try {
    const html = await fileCache.getFileContent(fileInfo.path);
    if (!html) return;
    
    logInfo(`[LOG1][writeCss] fileInfo: ${JSON.stringify(fileInfo)}`);
    logInfo(`[LOG2][writeCss] html head: ${html.slice(0, 200)}`);
    const classInfo = parseClass(html);
    
    if (multiFile?.output?.cssOutType === 'filePath') {
      // 直接文件模式：等待全量缓存更新完成后合并数据
      let retryCount = 0;
      const maxRetries = 5;
      
      while (!fullScanReadOnlyData.isLocked && retryCount < maxRetries) {
        logInfo('[直接文件模式] 等待全量缓存更新完成...');
        await new Promise(resolve => setTimeout(resolve, 200));
        retryCount++;
      }
      
      if (fullScanReadOnlyData.isLocked) {
        // 与更新后的全量数据合并
        const mergedClassSet = new Set(fullScanReadOnlyData.classListSet);
        const mergedStaticClassSet = new Set(fullScanReadOnlyData.userStaticClassListSet);
        
        // 清空cssWrite确保静态类能重新生成
        cssWrite.clear();
        
        let { cssStr, userBaseClassArr } = getClassList(mergedClassSet);
        let StaticClassStr = creatStaticClass(mergedStaticClassSet);
        let userBaseClassStr = creatUserBaseClassList(userBaseClassArr);
        const rendStr = cssStr + StaticClassStr + userBaseClassStr;
        await writeCssStr(rendStr, firstBuild, fileInfo);
        
        logInfo(`[直接文件模式] 使用更新后的全量数据生成CSS - 总class: ${mergedClassSet.size}, 总static: ${mergedStaticClassSet.size}`);
      } else {
        // 降级处理：使用当前文件数据
        cssWrite.clear();
        let { cssStr, userBaseClassArr } = getClassList(classInfo.classArr);
        let StaticClassStr = creatStaticClass(classInfo.userStaticClassArr);
        let userBaseClassStr = creatUserBaseClassList(userBaseClassArr);
        const rendStr = cssStr + StaticClassStr + userBaseClassStr;
        await writeCssStr(rendStr, firstBuild, fileInfo);
        
        logInfo(`[直接文件模式] 降级使用当前文件数据生成CSS`);
      }
    } else {
      // 统一文件模式使用增量更新处理
      await handleUnifiedFileMode(fileInfo, classInfo, firstBuild);
    }
    
  } catch (e) {
    logError('构建异常：' + e.message);
  }
}

// ====== 优雅退出处理 ======
process.on('SIGINT', () => {
  logInfo('正在优雅退出..');
  fileCache.clear();
  if (watcher) watcher.close();
  if (configWatcher) configWatcher.close();
  process.exit(0);
});

// ====== 新增：全量缓存状态监控优化 ======
setInterval(() => {
  if (fullScanReadOnlyData.isLocked) {
    const timeDiff = Date.now() - fullScanReadOnlyData.scanTime;
    logInfo(`[全量缓存状态] 最后更新: ${Math.floor(timeDiff/1000)}秒前, class: ${fullScanReadOnlyData.classListSet.size}, static: ${fullScanReadOnlyData.userStaticClassListSet.size}`);
    logInfo(`[当前工作数据] class: ${classListSet.size}, static: ${userStaticClassListSet.size}`);
  } else {
    logInfo(`[全量缓存状态] 未锁定 - 可能正在更新中`);
  }
}, 60000); // 每分钟输出一次状态
